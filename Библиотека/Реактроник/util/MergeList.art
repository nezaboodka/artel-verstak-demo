
import JS = Artel.JavaScript

external
{
  type GetMergedItemKey<T> = operation(item: T): Text?


  type MergeListReader<T> = aspect
  {
    guarded
    isStrict: YesNo

    guarded
    count: Number

    guarded
    addedCount: Number

    guarded
    removedCount: Number

    guarded
    isMergeInProgress: YesNo

    operation lookup(key: Text): MergedItem<T>?

    operation tryMergeAsExisting(key: Text): MergedItem<T>?

    operation mergeAsAdded(instance: T): MergedItem<T>

    operation mergeAsRemoved(item: MergedItem<T>)

    operation move(item: MergedItem<T>, after: MergedItem<T>)

    operation beginMerge()

    operation endMerge(error`: Object? = none)

    operation resetAddedAndRemovedLists()

    operation lastMergedItem(): MergedItem<T>?

    operation items(): Enumerable<MergedItem<T>>

    operation addedItems(reset: YesNo? = none): Enumerable<MergedItem<T>>

    operation removedItems(reset: YesNo? = none): Enumerable<MergedItem<T>>

    operation isAdded(item: MergedItem<T>): YesNo

    operation isMoved(item: MergedItem<T>): YesNo

    operation isRemoved(item: MergedItem<T>): YesNo

    operation isActual(item: MergedItem<T>): YesNo
  }


  type MergedItem<T> = aspect
  {
    guarded
    instance: T

    guarded
    index: Integer

    guarded
    next: MergedItem<T>?

    guarded
    prev: MergedItem<T>?

    aux: MergedItem<T>
  }


  #JS.ВнешняяРеализация(модуль = "reactronic")
  type MergeList<T> = object MergeListReader<T>
  {
    guarded
    getKey: GetMergedItemKey<T>

    // hidden
    // strict
  
    // hidden
    // map
  
    // hidden
    // tag
  
    // hidden
    // current
  
    // hidden
    // added
  
    // hidden
    // removed
  
    // hidden
    // lastNotFoundKey
  
    // hidden
    // strictNextItem?
  
    on create(getKey: GetMergedItemKey<T>, strict: YesNo = no)

    isStrict: YesNo

    guarded
    count: Number

    guarded
    addedCount: Number

    guarded
    removedCount: Number

    guarded
    isMergeInProgress: YesNo

    operation lookup(key: Text?): MergedItem<T>?

    operation tryMergeAsExisting(key: Text, resolution: object { isDuplicate: YesNo } | None = none, error`: Text? = none): MergedItem<T>?

    operation mergeAsAdded(instance: T): MergedItem<T>

    operation mergeAsRemoved(item: MergedItem<T>)

    operation move(item: MergedItem<T>, after: MergedItem<T>)

    operation beginMerge()

    operation endMerge(err: Object? = none)

    operation resetAddedAndRemovedLists()

    operation lastMergedItem(): MergedItem<T>?

    operation items(): Enumerable<MergedItem<T>>

    operation addedItems(reset: YesNo? = none): Enumerable<MergedItem<T>>

    operation removedItems(reset: YesNo? = none): Enumerable<MergedItem<T>>

    operation isAdded(item: MergedItem<T>): YesNo

    operation isMoved(item: MergedItem<T>): YesNo

    operation isRemoved(item: MergedItem<T>): YesNo

    operation isActual(item: MergedItem<T>): YesNo

    operation markAsMoved(item: MergedItem<T>)

    global 
    operation createItem<T>(instance: T): MergedItem<T>
  }
}
