import { Kind, SnapshotOptions } from "../Options.js";
import { AbstractChangeset, ObjectSnapshot, MemberName, ObjectHandle, ValueSnapshot, Observer } from "./Data.js";
export declare const MAX_REVISION: number;
export declare const UNDEFINED_REVISION: number;
export declare class Changeset implements AbstractChangeset {
    static idGen: number;
    private static stampGen;
    private static pending;
    private static oldest;
    static garbageCollectionSummaryInterval: number;
    static lastGarbageCollectionSummaryTimestamp: number;
    static totalObjectHandleCount: number;
    static totalObjectSnapshotCount: number;
    readonly id: number;
    readonly options: SnapshotOptions;
    get hint(): string;
    get timestamp(): number;
    private revision;
    private bumper;
    items: Map<ObjectHandle, ObjectSnapshot>;
    obsolete: Observer[];
    sealed: boolean;
    constructor(options: SnapshotOptions | null);
    static current: () => Changeset;
    static edit: () => Changeset;
    static markUsed: (observable: ValueSnapshot, os: ObjectSnapshot, m: MemberName, h: ObjectHandle, kind: Kind, weak: boolean) => void;
    static markEdited: (oldValue: any, newValue: any, edited: boolean, os: ObjectSnapshot, m: MemberName, h: ObjectHandle) => void;
    static isConflicting: (oldValue: any, newValue: any) => boolean;
    static propagateAllChangesThroughSubscriptions: (changeset: Changeset) => void;
    static revokeAllSubscriptions: (changeset: Changeset) => void;
    static enqueueReactiveFunctionsToRun: (reactive: Array<Observer>) => void;
    lookupObjectSnapshot(h: ObjectHandle, m: MemberName): ObjectSnapshot;
    getObjectSnapshot(h: ObjectHandle, m: MemberName): ObjectSnapshot;
    getEditableObjectSnapshot(h: ObjectHandle, m: MemberName, value: any, token?: any): ObjectSnapshot;
    static takeSnapshot<T>(obj: T): T;
    static dispose(obj: any): void;
    static doDispose(ctx: Changeset, h: ObjectHandle): ObjectSnapshot;
    private isNewSnapshotRequired;
    acquire(outer: Changeset): void;
    bumpBy(timestamp: number): void;
    rebase(): ObjectSnapshot[] | undefined;
    private merge;
    applyOrDiscard(error?: any): Array<Observer>;
    static sealObjectSnapshot(h: ObjectHandle, os: ObjectSnapshot): void;
    static sealValueSnapshot(o: ValueSnapshot | symbol, m: MemberName, typeName: string): void;
    static freezeObjectSnapshot(os: ObjectSnapshot): ObjectSnapshot;
    triggerGarbageCollection(): void;
    private unlinkHistory;
    static _init(): void;
}
export declare class Dump {
    static valueHint: (value: any) => string;
    static obj(h: ObjectHandle | undefined, m?: MemberName | undefined, stamp?: number, snapshotId?: number, originSnapshotId?: number, value?: any): string;
    static snapshot2(h: ObjectHandle, s: AbstractChangeset, m?: MemberName, o?: ValueSnapshot): string;
    static snapshot(os: ObjectSnapshot, m?: MemberName): string;
    static conflicts(conflicts: ObjectSnapshot[]): string;
    static conflictingMemberHint(m: MemberName, ours: ObjectSnapshot, theirs: ObjectSnapshot): string;
}
export declare const EMPTY_SNAPSHOT: ObjectSnapshot;
export declare const DefaultSnapshotOptions: SnapshotOptions;
