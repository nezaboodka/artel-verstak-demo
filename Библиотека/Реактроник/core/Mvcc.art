
import JS = Artel.JavaScript

external
{
  #JS.ВнешняяРеализация(модуль = "reactronic")
  hidden by package
  type MvccObject = /*(!) incomplete */ object
  {
    on create(observable: YesNo)

    // [Symbol.toStringTag](): string;
  }


  #JS.ВнешняяРеализация(модуль = "reactronic")
  type TransactionalObject = /*(!) incomplete */ object MvccObject
  {
    on create()
  }


  #JS.ВнешняяРеализация(модуль = "reactronic")
  type ObservableObject = /*(!) incomplete */ object MvccObject
  {
    on create()
  }


  #JS.ВнешняяРеализация(модуль = "reactronic")
  hidden by package
  type OptionsImpl = object MemberOptions
  {
    guarded
    getter: JS.Function

    guarded
    setter: JS.Function

    guarded
    kind: Kind

    guarded
    separation: SeparationMode

    guarded
    order: Number

    guarded
    no-side-effects: YesNo

    guarded
    triggering-args: YesNo

    guarded
    throttling: Number

    guarded
    reentrance: Reentrance

    guarded
    journal: Journal?

    guarded
    monitor: Monitor /*(!)| JS.Null*/

    guarded
    logging: PartialLoggingOptions?

    global guarded
    INITIAL: OptionsImpl

    on create(getter: JS.Function?, setter: JS.Function?,
      existing: OptionsImpl, patch: PartialMemberOptions,
      implicit: YesNo);
  }


  #JS.ВнешняяРеализация(модуль = "reactronic")
  hidden by package
  type Mvcc = object /*(!) JS.ProxyHandler<ObjectHandle>*/
  {
    global
    reactivity-auto-start-disabled: YesNo

    global
    repetitive-usage-warning-threshold: Number

    global
    main-thread-blocking-warning-threshold: Number

    global
    async-action-duration-warning-threshold: Number

    global
    sensitivity: YesNo

    global guarded
    transactional: Mvcc

    global guarded
    observable: Mvcc

    guarded
    is-observable: YesNo

    on create(is-observable: YesNo)

    operation get-prototype-of(h: ObjectHandle): Object /*(!)| JS.null*/

    operation get(h: ObjectHandle, m: MemberName, receiver: Object?): Object?

    operation set(h: ObjectHandle, m: MemberName, value: Object?, receiver: Object?): YesNo

    operation has(h: ObjectHandle, m: MemberName): YesNo

    operation define-property(h: ObjectHandle, m: Text | JS.Symbol, attributes: Object /*(!) JS.PropertyDescriptor*/): YesNo

    operation get-own-property-descriptor(h: ObjectHandle, m: MemberName): Object? /*(!) JS.PropertyDescriptor | undefined */

    operation own-keys(h: ObjectHandle): List<Text | JS.Symbol>;

    global
    operation decorate-data(isObservable: YesNo, proto: Object?, member: MemberName): Object?

    global
    operation decorate-operation(implicit: YesNo, decorator: JS.Function, options: PartialMemberOptions, proto: Object?, member: MemberName, pd: Object? /* (!) JS.PropertyDescriptor?*/): Object?

    global
    operation decorate-operation-parametrized(decorator: JS.Function, options: PartialMemberOptions): F<Object?>

    global
    operation acquire-handle(obj: Object?): ObjectHandle

    global
    operation create-handle-for-mvcc-object(proto: Object?, data: Object?, blank: Object?, hint: Text, isObservable: YesNo): ObjectHandle

    global
    operation set-profiling-mode(isOn: YesNo, options: ProfilingOptions? = none)

    global
    operation sensitive<T>(sensitivity: YesNo, func: F<T>, args: JS.МассивПараметров<Object?>): T

    global
    operation set-hint<T>(obj: T, hint: Text?): T

    global
    operation get-hint<T>(obj: T): Text

    global
    create-operation: operation(h: ObjectHandle, m: MemberName, options: OptionsImpl): F<Object?>

    global
    remember-operation-options: operation(proto: Object?, m: MemberName, getter: JS.Function?, setter: JS.Function?, enumerable: YesNo, configurable: YesNo, options: PartialMemberOptions, implicit: YesNo): OptionsImpl
  }
}
