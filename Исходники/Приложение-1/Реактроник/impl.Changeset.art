import artel
import artel.js

external
{
  // Snapshot

  #ВнешняяРеализация(модуль = "reactronic")
  type Changeset = object AbstractChangeset
  {
    global
    idGen: Integer

    global
    garbageCollectionSummaryInterval: Integer

    global
    lastGarbageCollectionSummaryTimestamp: Integer

    global
    totalObjectHandleCount: Integer

    global
    totalObjectSnapshotCount: Integer

    protected
    id: Integer

    protected
    options: SnapshotOptions

    items: Map<ObjectHandle, ObjectSnapshot>

    reactive`: List<Observer>

    sealed: Boolean

    on create(options: SnapshotOptions?)

    global
    current: operation(): Changeset

    global
    edit: operation(): Changeset

    global
    markUsed: operation(observable`: ObservableValue, os: ObjectSnapshot, m: MemberName, h: ObjectHandle, kind: Kind, weak: Boolean)

    global
    markEdited: operation(oldValue: /*(!) any */ Object?, newValue: /*(!) any */ Object?, edited: Boolean, os: ObjectSnapshot, m: MemberName, h: ObjectHandle): Ничего

    global
    isConflicting: operation(oldValue: /*(!) any */ Object?, newValue: /*(!) any */ Object?): Boolean

    global
    propagateAllChangesThroughSubscriptions: /*(!) any */ Object?

    global
    revokeAllSubscriptions: /*(!) any */ Object?

    global
    enqueueReactiveFunctionsToRun: /*(!) any */ Object?

    operation lookupObjectSnapshot(h: ObjectHandle, m: MemberName): ObjectSnapshot

    operation getObjectSnapshot(h: ObjectHandle, m: MemberName): ObjectSnapshot

    operation getEditableObjectSnapshot(h: ObjectHandle, m: MemberName, value: /*(!) any */ Object?, token: Object? = empty): ObjectSnapshot

    global
    operation takeSnapshot<T>(obj: T): T

    global
    operation dispose`(obj: Object?)

    global
    operation doDispose(ctx: Changeset, h: ObjectHandle): ObjectSnapshot

    operation acquire(outer: Changeset)

    operation bumpBy(timestamp: Integer)

    operation rebase(): List<ObjectSnapshot>?

    operation applyOrDiscard(err: Object? = empty): Array<Observer>

    global
    operation sealObjectSnapshot(h: ObjectHandle, os: ObjectSnapshot)

    global
    operation sealObservableValue(o: ObservableValue/*(!) | Символ*/, m: MemberName, typeName: Text)

    global
    operation freezeObjectSnapshot(os: ObjectSnapshot): ObjectSnapshot

    operation triggerGarbageCollection()

    protected
    hint: Text

    protected
    timestamp: Integer
  }

  //// Dump

  #ВнешняяРеализация(модуль = "reactronic")
  type Dump = object
  {
    global
    valueHint: Object?

    global
    operation obj(h: ObjectHandle?, m: MemberName? = empty, stamp: Integer? = empty, snapshotId: Integer? = empty, originSnapshotId: Integer? = empty, value: Object? = empty): Text

    global
    operation snapshot2(h: ObjectHandle, s: AbstractChangeset, m: MemberName? = empty, o: ObservableValue? = empty): Text

    global
    operation snapshot(os: ObjectSnapshot, m: MemberName? = empty): Text

    global
    operation conflicts(conflicts: List<ObjectSnapshot>): Text

    global
    operation conflictingMemberHint(m: MemberName, ours: ObjectSnapshot, theirs: ObjectSnapshot): Text
  }
}
